diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..3f91c38
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,20 @@
+{
+"C_Cpp.default.includePath": [
+  "${workspaceFolder}/include",
+  "${env:ZVB_SDK_PATH}/include",
+  "${env:ZVB_SDK_PATH}/sdcc",
+  "${env:ZOS_PATH}/kernel_headers/sdcc/include",
+  "${env:ZGDK_PATH}/include",
+],
+"files.associations": {
+  "*.asm": "z80-macroasm",
+  "stdint.h": "c",
+  "string.h": "c",
+  "memory_resource": "c",
+  "__node_handle": "cpp",
+  "locale": "c",
+  "source_location": "c",
+  "cstdlib": "c",
+  "stdio.h": "c"
+},
+}
\ No newline at end of file
diff --git a/Aseprite/Pong_Tiles.aseprite b/Aseprite/Pong_Tiles.aseprite
deleted file mode 100644
index e010e29aec7e44dcd9c1907bc288d3cde2d2c5fe..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 476
zcmcb^$iVPmDI>!H1_1^I1|Wwa1&9%VnSl``2$U5-2vU(112p~DM^><{tUz<cfS6qY
zY$cK{IzYCh0y9*E2}uUb{LjGf9|$09VIai<@(D;eL{uIm1lJBy22#t;;FDOHTBKlj
z1IS@j01`m(A8t4(L@MUIz2wQqY{<bHc>n*Ull#hbnZJ5+buKkLZ2i23Z^HQ%t3I2p
zdOm}%>i_m?ueGb||Gtj@|Lgkxe_!Xn+Om4xzxvzuweMH`+x~9ps`y*{vR`B~m*4*G
z^n3CD<-eD|pAuE>eW~ung75y;clU`~ZU4Qvx$IWx_xPe$|5pC>KU@F1Zr8gncY}Vt
z*j1nPKlt<geb?)k&EI0{$Nm;%boTrEruMR1F0b45YyIB+|K8u*KX>N0wGaoK|Ms8t
Io{Whc07b-(tN;K2

diff --git a/Makefile b/Makefile
index 9facc6d..68a2894 100644
--- a/Makefile
+++ b/Makefile
@@ -1,74 +1,98 @@
-#
-# SPDX-FileCopyrightText: 2024 Zeal 8-bit Computer <contact@zeal8bit.com>
-#
-# SPDX-License-Identifier: CC0-1.0
-#
+##
+# The build variables for ZGDK are all optional.
+# Override their value by uncommenting the corresponding line.
+##
 
-SHELL := /bin/bash
+##
+# Project specific
+##
 
-# Specify the files to compile and the name of the final binary
-SRCS=$(wildcard $(INPUT_DIR)/*.c)
+# Specify the name of the output binary.
 BIN=pong.bin
 
-# Directory where source files are and where the binaries will be put
-INPUT_DIR=src
-OUTPUT_DIR=bin
+# Specify the directory containing the source files.
+# INPUT_DIR=src
 
-# Include directory containing Zeal 8-bit OS header files.
-ifndef ZOS_PATH
-$(error "Please define ZOS_PATH environment variable. It must point to Zeal 8-bit OS source code path.")
+# Specify the build containing the compiled files.
+# OUTPUT_DIR=bin
+
+# Specify the files in the src directory to compile and the name of the final binary.
+# By default, all the C files inside `INPUT_DIR` are selected, the `INPUT_DIR` prefix must not be part of the files names.
+# SRCS=$(notdir $(wildcard $(INPUT_DIR)/*.c))
+
+# Specify the location of your asserts (aseprite, gif, zts, ztp, ztm, etc)
+# ASSETS_DIR=assets
+
+##
+# ZOS Specific
+##
+
+# Specify the shell to use for sub-commands.
+# SHELL = /bin/bash
+
+# Specify the C compiler to use.
+# ZOS_CC=sdcc
+
+# Specify the linker to use.
+# ZOS_LD=sdldz80
+
+# Specify additional flags to pass to the compiler.
+# ZOS_CFLAGS=
+
+# Specify additional flags to pass to the linker.
+# ZOS_LDFLAGS=
+
+# Specify the `objcopy` binary that performs the ihex to bin conversion.
+# By default it uses `sdobjcopy` or `objcopy` depending on which one is installed.
+# OBJCOPY=$(shell which sdobjcopy objcopy | head -1)
+
+##
+# ZVB Specific
+##
+
+# Specify additional flags to pass to the compiler. This will be concatenated to `ZOS_CFLAGS`.
+# ZVB_CFLAGS=-I$(ZVB_SDK_PATH)/include/
+
+# Specify additional flags to pass to the linker. This will be concatenated to `ZOS_LDFLAGS`.
+# ZVB_LDFLAGS=-k $(ZVB_SDK_PATH)/lib/ -l zvb_gfx
+
+# ZGDK has sound enabled by default, uncomment this to disable sound and reduce your binary size
+# ENABLE_SOUND=0
+# ENABLE_CRC32=1
+
+##
+# ZGDK Specific
+##
+
+# ASEPRITE_PATH ?= ~/.steam/debian-installation/steamapps/common/Aseprite/aseprite
+# GIF_SRCS=$(ASEPRITE_SRCS:.aseprite=.gif)
+# ZTS_SRCS=$(GIF_SRCS:.gif=.zts)
+# ZTM_SRCS=$(TILEMAP_SRCS:.tmx=.ztm)
+
+# Set these #define flags
+# EMULATOR=1
+# FRAMELOCK=1
+# DEBUG=1
+
+##
+# User Defined
+##
+
+# EXTRA_CFLAGS= -I$(ZGDK_PATH)/include
+# EXTRA_LDFLAGS= -k $(ZGDK_PATH)/lib -l zgdk -l zvb_sound
+
+# GFX_BITS = 1
+# GFX_COMPRESSED = 0
+# GFX_STRIP = 128
+
+ifdef BREAK
+ZOS_CFLAGS += -DBREAK
 endif
-ifndef ZVB_SDK_PATH
-$(error "Please define ZVB_SDK_PATH environment variable. It must point to Zeal Video Board SDK path.")
+
+ifndef ZGDK_PATH
+    $(error "Failure: ZGDK_PATH variable not found. It must point to ZGDK path.")
 endif
-ZVB_INCLUDE=$(ZVB_SDK_PATH)/include/
-ZOS_INCLUDE=$(ZOS_PATH)/kernel_headers/sdcc/include/
-ZVB_LIB_PATH=$(ZVB_SDK_PATH)/lib/
-ZOS_LIB_PATH=$(ZOS_PATH)/kernel_headers/sdcc/lib
-# Regarding the linking process, we will need to specify the path to the crt0 REL file.
-# It contains the boot code for C programs as well as all the C functions performing syscalls.
-CRT_REL=$(ZOS_PATH)/kernel_headers/sdcc/bin/zos_crt0.rel
-
-
-# Compiler, linker and flags related variables
-CC=sdcc
-# Specify Z80 as the target, compile without linking, and place all the code in TEXT section
-# (_CODE must be replace).
-CFLAGS=-mz80 --opt-code-speed -c --codeseg TEXT -I$(ZOS_INCLUDE) -I$(ZVB_INCLUDE)
-LD=sdldz80
-# Make sure the whole program is relocated at 0x4000 as request by Zeal 8-bit OS.
-LDFLAGS=-n -mjwx -i -b _HEADER=0x4000 -k $(ZOS_LIB_PATH) -l z80 -k $(ZVB_LIB_PATH) -l zvb_gfx
-# Binary used to convert ihex to binary
-OBJCOPY=objcopy
-
-# Generate the intermediate Intel Hex binary name
-BIN_HEX=$(patsubst %.bin,%.ihx,$(BIN))
-# Generate the rel names for C source files. Only keep the file names, and add output dir prefix.
-SRCS_REL=$(subst $(INPUT_DIR)/,$(OUTPUT_DIR)/,$(patsubst %.c,%.rel,$(SRCS)))
-SRCS_ASM_REL=$(subst $(INPUT_DIR)/,$(OUTPUT_DIR)/,$(patsubst %.asm,%.rel,$(SRCS)))
-
-
-.PHONY: all clean
-
-all: clean $(OUTPUT_DIR) $(OUTPUT_DIR)/$(BIN_HEX) $(OUTPUT_DIR)/$(BIN)
-	@bash -c 'echo -e "\x1b[32;1mSuccess, binary generated: $(OUTPUT_DIR)/$(BIN)\x1b[0m"'
-
-$(OUTPUT_DIR):
-	mkdir -p $(OUTPUT_DIR)
-
-# Generate a REL file for each source file. In fact, SDCC doesn't support compiling multiple source file
-# at once. We have to create the same directory structure in output dir too.
-$(SRCS_REL): $(OUTPUT_DIR)/%.rel : $(INPUT_DIR)/%.c
-	@mkdir -p $(OUTPUT_DIR)/$(dir $*)
-	$(CC) $(CFLAGS) -o $(OUTPUT_DIR)/$(dir $*) $<
-
-# Generate the final Intel HEX binary.
-$(OUTPUT_DIR)/$(BIN_HEX): $(CRT_REL) $(SRCS_REL)
-	$(LD) $(LDFLAGS) $(OUTPUT_DIR)/$(BIN_HEX) $(CRT_REL) $(SRCS_REL)
-
-# Convert the Intel HEX file to an actual binary.
-$(OUTPUT_DIR)/$(BIN):
-	$(OBJCOPY) --input-target=ihex --output-target=binary $(OUTPUT_DIR)/$(BIN_HEX) $(OUTPUT_DIR)/$(BIN)
-
-clean:
-	rm -fr bin/
\ No newline at end of file
+
+include $(ZGDK_PATH)/base_sdcc.mk
+
+## Add your own rules here
\ No newline at end of file
diff --git a/assets/Pong_Tiles.gif b/assets/Pong_Tiles.gif
deleted file mode 100644
index 5a76a8f26e3699edb0ea1f8e5f02fa962bd4e94c..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 255
zcmV<b0093-Nk%v~VZZ<o0CxZYA^!_bMO0HmK~P09E-(WD0000X`2+|G0000i00000
zzyJ^cfB*mh|Ns92!-S8iYvIAvn{>uiv)=9^>xEVLQRGR2B4?uPyPYa3wX#j;WtYPI
z?F&MBKiy&E!Wnb3i;yOK5{Ju%(u1rrA3zv1>eDW>)1r9VeSN{|^R|h-y5|6CnysNH
z;ZC_;Y*&Vt@h7;(RhYOEmN>}L#}`4SNSP3*=g0wxcvo3t=5|S!86)Y(FzFeoB|1l%
zXS#}U+Q>N?)OGhtH7omR>sbdJii;+=y9wHxTIp-lx~%(}%p1#0>8u0&D@{s$tb9-a
F06R)`bc_H1

diff --git a/assets/gif2zeal.py b/assets/gif2zeal.py
deleted file mode 100755
index 9eb9cd3..0000000
--- a/assets/gif2zeal.py
+++ /dev/null
@@ -1,155 +0,0 @@
-#!/usr/bin/env python3
-
-import math
-from functools import reduce
-from PIL import Image
-import argparse
-from pathlib import Path
-
-
-parser = argparse.ArgumentParser("gif2zeal")
-parser.add_argument("-i", "--input", help="Input GIF Filename", required=True)
-parser.add_argument("-t","--tileset", help="Zeal Tileset (ZTS)")
-parser.add_argument("-p", "--palette", help="Zeal Palette (ZTP)")
-parser.add_argument("-b", "--bpp", help="Bits Per Pixel", type=int, default=8, choices=[1,4,8])
-parser.add_argument("-c", "--compress", help="Compress with RLE", action="store_true")
-parser.add_argument("-s", "--strip", help="Strip N tiles off the end", type=int, default=0)
-
-tile_width = 16
-tile_height = 16
-
-def RGBtoRGB565(r,g,b):
-  red = (r >> 3) & 0x1F
-  green = (g >> 2) & 0x3F
-  blue = (b >> 3) & 0x1F
-  return (red << 11) | (green << 5) | blue
-
-def getPalette(gif):
-  if not gif.mode == "P":
-    print("Invalid Mode, expected P and got ", gif.mode)
-    exit(2)
-  palette = gif.getpalette() # rawmode="BGR;16")
-  if palette == None:
-    print("invalid GIF palette")
-    exit(2)
-
-  result = []
-
-  for x in range(0, len(palette), 3):
-    # print("x", x)
-    # print("x", x, end="   ")
-    r = palette[x]
-    g = palette[x+1]
-    b = palette[x+2]
-    color = reduce(lambda acc, x: (acc << 8) + x, [r,g,b])
-    # print("rgb   ", str(r).rjust(3), str(g).rjust(3), str(b).rjust(3), "#{:06x}".format(color), end=" | ")
-    color = RGBtoRGB565(r,g,b)
-    # print("rgb565", "#{:06x}".format(color), str(color).rjust(5))
-
-    lo = color & 0xFF
-    hi = (color >> 8) & 0xFF
-
-    result.append(lo)
-    result.append(hi)
-    # print("[{}]".format(", ".join(hex(x) for x in palette)))
-  return result
-
-def _compress_same_seq(data):
-  count = 0
-  i = 0
-  while (i < len(data)) and (data[0] == data[i] and count < 128):
-    count += 1
-    i += 1
-
-  return count
-
-def _compress_diff_seq(data):
-  count = 0
-  i = 1
-  while (i < len(data)) and (data[i-1] != data[i] and count < 128):
-    count += 1
-    i += 1
-
-  return count
-
-def compress(tile: list):
-  ret = []
-  i = 0
-  while i < len(tile): # TILE_SIZE # 16 * 16
-    same_count = _compress_same_seq(tile[i:])
-    diff_count = _compress_diff_seq(tile[i:])
-
-    if diff_count > 0:
-      ret.append(diff_count - 1)
-      for j in range(i, i+diff_count):
-        ret.append(tile[j])
-      i += diff_count
-    else:
-      ret.append((same_count - 1) + 0x80)
-      ret.append(tile[i])
-      i += same_count
-
-  return ret
-
-def convert(args):
-  gif = Image.open(args.input)
-  palette = getPalette(gif)
-  # print("palette", palette)
-
-  tiles = []
-  tiles_per_row = int(gif.width / tile_width)
-  rows = int(gif.height / tile_height)
-
-  for y in range(0, rows):
-    for x in range(0, tiles_per_row):
-      if args.strip > 0 and y == rows - 1 and x >= tiles_per_row - args.strip:
-        continue
-      # print("tile", x, y)
-      ox = (x * tile_width)
-      oy = (y * tile_height)
-      tile = gif.crop((ox, oy, ox + tile_width, oy + tile_height))
-      pixels = list(tile.getdata())
-
-      if(args.bpp == 4):
-        op = pixels.copy()
-        pixels = []
-        for idx in range(0, len(op), 2):
-          p1 = op[idx]
-          p2 = op[idx+1]
-          p1 <<= 4
-          pixels.append(p1 + p2)
-
-
-      if(args.compress):
-        pixels = compress(pixels)
-      tiles += pixels
-
-  print("columns", tiles_per_row, "rows", rows, "tiles", (tiles_per_row * rows) - args.strip)
-  return (tiles, palette)
-
-def main():
-  args = parser.parse_args()
-  print("args", args)
-  tileset, palette = convert(args)
-
-  tilesetFileName = args.tileset
-  if tilesetFileName == None:
-    tilesetFileName = Path(args.input).with_suffix(".zts")
-  paletteFileName = args.palette
-  if paletteFileName == None:
-    paletteFileName = Path(args.input).with_suffix(".ztp")
-
-  print("tileset", tilesetFileName) #, tileset)
-  print("palette", paletteFileName) #, palette)
-
-  # tilesetFile = bytearray(tileset)
-  # paletteFile = bytearray(palette)
-
-  with open(tilesetFileName, "wb") as file:
-    file.write(bytearray(tileset))
-
-  with open(paletteFileName, "wb") as file:
-    file.write(bytearray(palette))
-
-if __name__ == "__main__":
-  main()
\ No newline at end of file
diff --git a/assets/numbers.gif b/assets/numbers.gif
deleted file mode 100644
index ae8a8eede0c4c80b008e4e3acec98e026ece876b..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 325
zcmV-L0lNN2Nk%v~VE_RT0Du4h00030|NkNX3r<B;Q$s;eMKUfh0|5X403rDV2mt^9
z04x9i000015C8xI|AddJ%k2-NoV41Dv);V>4~F7Mmgb43>dIEZ3kOd8#BgK3xPCLa
z?91(JLt2p7N@jou<^t$^CZdQawF!`EaZ_&9i}iKI-<b~5Q;M`abGAmi8i?}ut<Fv>
z^5<uqdk5Gy^M+Q)@l!{#wMD3SI9C%URYp0vHztXfiCK9Rp{GIhxMl|_^~jex=ofgz
zis`B;*w_lI_G+}kcp5uPQR@iWi^XfWY5Y3`+Gj@U(!7yJ{FR!eyZ3io6x<~%EcOkk
z3{KwBEy{^1>8bvVeo1}$E^jrw`X2oW5-KX>3<rs=eyzCaYw|Ck!F<mo9Q1=LqQr?5
XD_XpWF{8$f2^>3m{0K7S#R333#YvTl

diff --git a/assets/pong.aseprite b/assets/pong.aseprite
new file mode 100644
index 0000000000000000000000000000000000000000..d051e9fc68b47433822158a330f062cc74e63063
GIT binary patch
literal 486
zcmaFH$iVPmDUe`PVBlZ?(hMm;i~vjwj37Y<0U)FWNCTSw>mv);Ru-TIVnEEU0Jajz
zI*{EgAlESg8UO$Pmk03`n2}Wc2eR22d=e{Dixdn6fht)QKmtJ3AT40<nL(DJV$R#J
zw|q>79LewhUz!!;leg48^2Xo7D=trybCy27(vwv4(6)Sos9;F#nkk?2T!ObPyE7#+
z=IQZj^QZ3bS7)434|wK&BKXwyC7SK`dM`YkT@?Im-m*E%|7<uNX7aSXXaAx*8FP57
z+8yWIP<y2Mo3-cm@At1c9^Km)_w$eGZ64`>yc0_=E-}ipsGO5~M6PjeB)>2Fsf_h;
zJRzLklh#H1Zmn$Jbt?InhePl&F|MnvT|1hCD}U4+OxS;F-?Tkh2iL4Ww(?Y0f=u}4
z#c3A<HCFlfKk(C8=O~lDdDo{S$3(Bz6g9oo+Rc@{|MZSUv*ufFl>OoVm$}%0bsqrX
C>XRk_

literal 0
HcmV?d00001

diff --git a/assets/pong.gif b/assets/pong.gif
new file mode 100644
index 0000000000000000000000000000000000000000..c2a8d2b34278d820b01eba82df3777e1919ada2e
GIT binary patch
literal 523
zcmV+m0`&byNk%v~VE_Rj0Du4h00030|NkNX3r<B;Q$s;eMKUfh0|5X403rDV2?_uJ
z04x9i00001AOHXY|AddJYvIAvn{>uiv)=9^>xEVLQRIoH>gs_aXQJ@Doi5wNwvPAy
zFMI50kRb6`e06>!qYwy<N&&YEGKIX7s;uVlISq@Q-x)Sb9JhE%u=)+pE!$=%niI#c
z*WA4SpP*HCrvZ52wY6us7$=xWh_{GHm&9m!DRHC*31g)gF^MV4=s3k0$q?$<H`*#!
z8C5EES_Ar-dh066>LVLVo3ZLfsat$F4CSjg#|O+ym7Do&Oo|MoEDdYx{H&TCO>H>c
zrTM6h%WZu;4jmls%C3SPsQ%3@%)IUW&fo9<4=|v>fdmU0JczJbu4(R;@e)$6p}ljj
zBJPuza8n>F&kb5^O!W~1m5~%jegG9xLdumTVU?8gDC0(mo=ob4(9%N7b~aVs!ue1q
zN}3>v4&BnT7sfm|NqT&l6l#*4CqY&fd6gs8LnyN@i<wNNIHyvR`efK4r_pa_xvo80
zH0{l{@Rl|r`!p{Wx-*gPYznpGU#BAY!c+owR=!?5%Q_DFw&>iyatl*#YFV#ltzj^S
z_3G0jXs)9}TP2MZHRsbEGp|bg+SKA6c1uXTxX<>@*%f)yQ_HU23g7f(8b6Lax$@=A
Nn>&9FJ^G0P06SC^_DcW&

literal 0
HcmV?d00001

diff --git a/src/assets.c b/src/assets.c
new file mode 100644
index 0000000..19b9f65
--- /dev/null
+++ b/src/assets.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+#include <zvb_gfx.h>
+#include "assets.h"
+
+gfx_error load_palette(gfx_context* ctx)
+{
+    // Load the palette
+    const size_t palette_size = &_palette_end - &_palette_start;
+    return gfx_palette_load(ctx, &_palette_start, palette_size, 0);
+}
+
+gfx_error load_tiles(gfx_context* ctx, gfx_tileset_options* options)
+{
+    const size_t size = &_tiles_end - &_tiles_start;
+    return gfx_tileset_load(ctx, &_tiles_start, size, options);
+}
+
+uint8_t* get_tilemap_start(void) {
+    return &_tilemap_start;
+}
+
+uint8_t* get_tilemap_end(void) {
+    return &_tilemap_end;
+}
+
+void __assets__(void) {
+    __asm__(
+    // pong palette
+    "__palette_start:\n"
+    "    .incbin \"assets/pong.ztp\"\n"
+    "__palette_end:\n"
+    // pong tiles
+    "__tiles_start:\n"
+    "    .incbin \"assets/pong.zts\"\n"
+    "__tiles_end:\n"
+
+    // tilemap
+    "__tilemap_start:\n"
+    "    .incbin \"assets/tilemap.ztm\"\n"
+    "__tilemap_end:\n"
+    );
+}
\ No newline at end of file
diff --git a/src/assets.h b/src/assets.h
new file mode 100644
index 0000000..a1d3546
--- /dev/null
+++ b/src/assets.h
@@ -0,0 +1,13 @@
+
+extern uint8_t _palette_end;
+extern uint8_t _palette_start;
+extern uint8_t _tiles_end;
+extern uint8_t _tiles_start;
+extern uint8_t _tilemap_start;
+extern uint8_t _tilemap_end;
+
+gfx_error load_palette(gfx_context* ctx);
+gfx_error load_tiles(gfx_context* ctx, gfx_tileset_options* options);
+
+uint8_t* get_tilemap_start(void);
+uint8_t* get_tilemap_end(void);
\ No newline at end of file
diff --git a/src/controller.c b/src/controller.c
deleted file mode 100644
index 53151de..0000000
--- a/src/controller.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * SPDX-FileCopyrightText: 2024 Zeal 8-bit Computer <contact@zeal8bit.com>
- *
- * SPDX-License-Identifier: CC0-1.0
- */
-
-#include <stdio.h>
-#include <zos_errors.h>
-#include <zos_keyboard.h>
-#include "controller.h"
-
-/**
- * @brief Define some variables to access the PIO from C code
- */
-__sfr __at(0xd0) IO_PIO_DATA_A;
-__sfr __at(0xd2) IO_PIO_CTRL_A;
-
-#define CLOCK_ONCE() do { IO_PIO_DATA_A = 0; IO_PIO_DATA_A = 1 << IO_CLOCK; } while (0)
-#define GET_DATA()   (IO_PIO_DATA_A & (1 << IO_DATA))
-
-#define IO_PIO_DISABLE_INT  0x03
-#define IO_PIO_BITCTRL      0xcf
-
-#define IO_DATA     0
-#define IO_LATCH    2
-#define IO_CLOCK    3
-
-zos_err_t controller_flush(void) {
-    buttons = 0;
-    return ERR_SUCCESS;
-}
-
-zos_err_t controller_init(void)
-{
-    /**
-    * Initialize the user port (port A) of the PIO
-    * Set it to bit control mode so that each I/O can be controlled independently.
-    */
-    IO_PIO_CTRL_A = IO_PIO_BITCTRL;
-    /**
-     * After setting the port as a bit-controlled one, we need to give a bitmask of
-     * pins that needs to be output (0) and input (1).
-     * Set them all to output except DATA pins.
-     */
-    IO_PIO_CTRL_A = 3;
-    /* Disable the interrupts for this port just in case it was activated */
-    IO_PIO_CTRL_A = IO_PIO_DISABLE_INT;
-    /**
-     * Set the default value of each pin:
-     *  - LATCH must be LOW (0)
-     *  - CLOCK must be HIGH (1)
-     * Set other pins to 0, not very important
-     */
-    IO_PIO_DATA_A = 1 << IO_CLOCK;
-
-    return ERR_SUCCESS;
-}
-
-/**
- * @brief Read the controller state
- */
-uint16_t controller_read(void)
-{
-    /**
-     * Generate a pulse on the LATCH pin, CLOCK must remain high during this process
-     * Thanks to the preconfigured registers, this takes 24 T-States (2.4 microseconds @ 10MHz)
-     */
-    IO_PIO_DATA_A = 1 << IO_CLOCK | 1 << IO_LATCH;
-    IO_PIO_DATA_A = 1 << IO_CLOCK;
-    // Now, the DATA lines contain the first button (B) state.
-
-    buttons = GET_DATA() == 0 ? 0x8000 : 0;
-    // process the remaining 1 buttons (last 4 are unused)
-    for(uint8_t i = 0; i < 11; ++i) {
-        buttons = buttons >> 1;
-        CLOCK_ONCE(); // pulse the clock
-        buttons |= GET_DATA() == 0 ? 0x8000 : 0; // OR the current button
-    }
-    // shift over the 4 last unused bits
-    buttons >>= 4;
-
-    return buttons;
-}
\ No newline at end of file
diff --git a/src/controller.h b/src/controller.h
deleted file mode 100644
index 88574a8..0000000
--- a/src/controller.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * SPDX-FileCopyrightText: 2024 Zeal 8-bit Computer <contact@zeal8bit.com>
- *
- * SPDX-License-Identifier: CC0-1.0
- */
-#pragma once
-
-#include <stdint.h>
-
-#define SNES_B          0x0001  // 1
-#define SNES_Y          0x0002  // 2
-#define SNES_SELECT     0x0004  // 3
-#define SNES_START      0x0008  // 4
-#define SNES_UP         0x0010  // 5
-#define SNES_DOWN       0x0020  // 6
-#define SNES_LEFT       0x0040  // 7
-#define SNES_RIGHT      0x0080  // 8
-#define SNES_A          0x0100  // 9
-#define SNES_X          0x0200  // 10
-#define SNES_L          0x0400  // 11
-#define SNES_R          0x0800  // 12
-#define SNES_UNUSED1    0x1000  // 13
-#define SNES_UNUSED2    0x2000  // 14
-#define SNES_UNUSED3    0x4000  // 15
-#define SNES_UNUSED4    0x8000  // 16
-
-static uint16_t buttons = 0; // nothing
-
-zos_err_t controller_init(void);
-zos_err_t controller_flush(void);
-
-uint16_t controller_read(void);
-static inline uint8_t controller_pressed(uint16_t button) {
-    return buttons & button;
-}
\ No newline at end of file
diff --git a/src/keyboard.c b/src/keyboard.c
deleted file mode 100644
index 60090de..0000000
--- a/src/keyboard.c
+++ /dev/null
@@ -1,109 +0,0 @@
-#include <stdio.h>
-#include <zos_sys.h>
-#include <zos_vfs.h>
-#include <zos_keyboard.h>
-#include "keyboard.h"
-#include "controller.h"
-
-static uint8_t key_buffer[32];
-
-zos_err_t keyboard_flush(void) {
-  /* Flush the keyboard fifo */
-  keys = 0;
-  uint16_t size = sizeof(key_buffer);
-  while (size) {
-    zos_err_t err = read(DEV_STDIN, key_buffer, &size);
-    if(err != ERR_SUCCESS) {
-      return err;
-    }
-  }
-  return ERR_SUCCESS;
-}
-
-zos_err_t keyboard_init(void) {
-  /* Initialize the keyboard by setting it to raw and non-blocking */
-  void* arg = (void*) (KB_READ_NON_BLOCK | KB_MODE_RAW);
-  zos_err_t err = ioctl(DEV_STDIN, KB_CMD_SET_MODE, arg);
-  if(err != ERR_SUCCESS) {
-    return err;
-  }
-
-  return keyboard_flush();
-}
-
-uint16_t keyboard_read(void) {
-  uint16_t size = sizeof(key_buffer);
-  while(1) {
-    zos_err_t err = read(DEV_STDIN, key_buffer, &size);
-    if(err != ERR_SUCCESS) {
-      printf("Failed to read DEV_STDIN, clearing keys: %d", err);
-      keys = 0;
-      return keys;
-    }
-
-    if (size == 0) {
-      return keys;
-    }
-
-    uint8_t released = 0;
-    for (uint8_t i = 0; i < size; i++) {
-      if (key_buffer[i] == KB_RELEASED) {
-        released = 1;
-      } else {
-        switch(key_buffer[i]) {
-          case KB_KEY_W:
-          case KB_UP_ARROW:
-            if(released) {
-              keys &= ~SNES_UP;
-            } else {
-              keys |= SNES_UP;
-            }
-            break;
-
-          case KB_KEY_S:
-          case KB_DOWN_ARROW:
-            if(released) {
-              keys &= ~SNES_DOWN;
-            } else {
-              keys |= SNES_DOWN;
-            }
-            break;
-
-          case KB_KEY_A:
-          case KB_LEFT_ARROW:
-            if(released) {
-              keys &= ~SNES_LEFT;
-            } else {
-              keys |= SNES_LEFT;
-            }
-            break;
-
-          case KB_KEY_D:
-          case KB_RIGHT_ARROW:
-            if(released) {
-              keys &= ~SNES_RIGHT;
-            } else {
-              keys |= SNES_RIGHT;
-            }
-            break;
-
-          case KB_KEY_ENTER:
-            if(released) {
-              keys &= ~SNES_START;
-            } else {
-              keys |= SNES_START;
-            }
-            break;
-          case KB_KEY_SPACE:
-            if(released) {
-              keys &= ~SNES_B;
-            } else {
-              keys |= SNES_B;
-            }
-            break;
-        }
-        released = 0;
-      }
-    }
-  }
-}
diff --git a/src/keyboard.h b/src/keyboard.h
deleted file mode 100644
index a177ed8..0000000
--- a/src/keyboard.h
+++ /dev/null
@@ -1,13 +0,0 @@
-#pragma once
-
-#include <stdint.h>
-
-static uint16_t keys = 0;
-
-zos_err_t keyboard_init(void);
-zos_err_t keyboard_flush(void);
-
-uint16_t keyboard_read(void);
-static inline uint8_t keyboard_pressed(uint16_t key) {
-    return keys & key;
-}
\ No newline at end of file
diff --git a/src/pong.c b/src/pong.c
index 96aee25..99c9e45 100644
--- a/src/pong.c
+++ b/src/pong.c
@@ -8,29 +8,18 @@
 #include <zos_video.h>
 #include <zvb_gfx.h>
 #include <zvb_hardware.h>
-#include "controller.h"
-#include "keyboard.h"
-#include "utils.h"
+#include <zgdk.h>
+#include "assets.h"
 #include "pong.h"
 
 gfx_context vctx;
-Player player;
+Player player1;
 Player player2;
 Player ball;
 static uint8_t controller_mode = 1;
 static uint8_t frames = 0;
 // static uint16_t buttons = 0;
 
-#define PLAYER_SPEED   1
-#define BALL_WIDTH     3
-#define PLAYER_HEIGHT  16
-#define PLAYER_WIDTH   16
-#define REAL_PLAYER_WIDTH  6
-#define SCREEN_TOP_BOUNDARY   24
-#define SCREEN_BOTTOM_BOUNDARY   232
-#define BALL_TOP_BOUNDARY   8
-#define BALL_BOTTOM_BOUNDARY   232
-
 static uint8_t tilemap[WIDTH * HEIGHT];
 
 int main(void) {
@@ -77,64 +66,53 @@ void init(void) {
     err = gfx_initialize(ZVB_CTRL_VID_MODE_GFX_320_8BIT, &vctx);
     if (err) exit(1);
 
-    // Load the palette
-    extern uint8_t _pong_palette_end;
-    extern uint8_t _pong_palette_start;
-    size_t size = &_pong_palette_end - &_pong_palette_start;
-    err = gfx_palette_load(&vctx, &_pong_palette_start, size, 0);
+    err = load_palette(&vctx);
     if (err) exit(1);
 
-    // Load the tiles
-    extern uint8_t _pong_tileset_end;
-    extern uint8_t _pong_tileset_start;
-    size = &_pong_tileset_end - &_pong_tileset_start;
     gfx_tileset_options options = {
-        .compression = TILESET_COMP_NONE,
+        .compression = TILESET_COMP_RLE,
     };
-    err = gfx_tileset_load(&vctx, &_pong_tileset_start, size, &options);
-    if (err) exit(1);
 
-    extern uint8_t _numbers_tileset_end;
-    extern uint8_t _numbers_tileset_start;
-    size = &_numbers_tileset_end - &_numbers_tileset_start;
-    options.compression = TILESET_COMP_RLE;
-    options.from_byte = TILE_SIZE * 44; // 0x6100 // ASCII 44, comma
-    err = gfx_tileset_load(&vctx, &_numbers_tileset_start, size, &options);
+    err = load_tiles(&vctx, &options);
     if (err) exit(1);
 
+    ascii_map(',', 16, 16);
 
     // Draw the tilemap
     load_tilemap();
 
     // Setup the player
-    player.sprite.x = 16;
-    player.sprite.y = 120;
-    player.score = 0;
-    player.level = 1;
-    player.sprite_index = PLAYER_TILE;
-    player.sprite.flags = SPRITE_NONE;
-    player.sprite.tile = PLAYER_TILE;
-    gfx_sprite_set_tile(&vctx, 0, PLAYER_TILE);
+    player1.sprite.x = 16;
+    player1.sprite.y = 120;
+    player1.score = 0;
+    player1.level = 1;
+    player1.sprite_index = 1;
+    player1.sprite.flags = SPRITE_NONE;
+    player1.sprite.tile = PLAYER1_TILE;
+    gfx_sprite_render(&vctx, player1.sprite_index, &player1.sprite);
+    // gfx_sprite_set_tile(&vctx, 0, PLAYER_TILE);
 
     // Setup the ball
     ball.sprite.x = 160;
     ball.sprite.y = 128;
     ball.score = 0;
     ball.level = 1;
-    ball.sprite_index = BALL_TILE;
+    ball.sprite_index = 2;
     ball.sprite.flags = SPRITE_NONE;
     ball.sprite.tile = BALL_TILE;
-    gfx_sprite_set_tile(&vctx, 1, BALL_TILE);
+    gfx_sprite_render(&vctx, ball.sprite_index, &ball.sprite);
+    // gfx_sprite_set_tile(&vctx, 1, BALL_TILE);
 
     // Setup player 2
     player2.sprite.x = 320;
     player2.sprite.y = 180;
     player2.score = 0;
     player2.level = 1;
-    player2.sprite_index = PLAYER2_TILE;
+    player2.sprite_index = 3;
     player2.sprite.flags = SPRITE_NONE;
     player2.sprite.tile = PLAYER2_TILE;
-    gfx_sprite_set_tile(&vctx, 2, PLAYER2_TILE);
+    gfx_sprite_render(&vctx, player2.sprite_index, &player2.sprite);
+    // gfx_sprite_set_tile(&vctx, 2, PLAYER2_TILE);
 
     gfx_enable_screen(1);
 }
@@ -150,10 +128,10 @@ void load_tilemap(void) {
     uint8_t line[WIDTH];
 
     // Load the tilemap
-    extern uint8_t _pong_tilemap_start;
+    uint8_t *tilemap_start = get_tilemap_start();
     for (uint16_t y = 0; y < HEIGHT; y++) {
         uint16_t offset = y * WIDTH;
-        memcpy(&line, &_pong_tilemap_start + offset, WIDTH);
+        memcpy(&line, tilemap_start + offset, WIDTH);
         memcpy(&tilemap[offset], &line, WIDTH);
         gfx_tilemap_load(&vctx, line, WIDTH, TILEMAP_LAYER, 0, y);
     }
@@ -164,13 +142,13 @@ uint8_t input(void) {
     if(controller_mode == 1) {
         buttons |= controller_read();
     }
-    //player.h_direction = 0;
-    player.v_direction = 0;
-    //if(buttons & SNES_RIGHT) player.h_direction = 1;
-    //if(buttons & SNES_LEFT) player.h_direction = -1;
-    if(buttons & SNES_DOWN) player.v_direction = 1;
-    if(buttons & SNES_UP) player.v_direction = -1;
-    if(buttons & SNES_START) return 0;
+
+    player1.v_direction = 0;
+
+    if(buttons & BUTTON_DOWN) player1.v_direction = 1;
+    if(buttons & BUTTON_UP) player1.v_direction = -1;
+    if(buttons & BUTTON_START) return 0;
+
     return 255;
 }
 /*
@@ -192,7 +170,7 @@ void update(void) {
 
     static int8_t dx =1;
     static int8_t dy =1;
-    int8_t angle = (player.sprite.y - ball.sprite.y)/8;
+    int8_t angle = (player1.sprite.y - ball.sprite.y)/8;
     int8_t angle2 = (player2.sprite.y - ball.sprite.y)/8;
    
        /*
@@ -215,11 +193,11 @@ void update(void) {
     ball.sprite.y += dy;
     
     //Player 1 bouncing physics
-    player.sprite.y += player.v_direction*2;
-    if ((ball.sprite.x - BALL_WIDTH <= player.sprite.x) && 
-       (ball.sprite.x - BALL_WIDTH >= player.sprite.x - REAL_PLAYER_WIDTH) && 
-       (ball.sprite.y <= player.sprite.y) && 
-       (ball.sprite.y >= (player.sprite.y - PLAYER_HEIGHT))) 
+    player1.sprite.y += player1.v_direction*2;
+    if ((ball.sprite.x - BALL_WIDTH <= player1.sprite.x) && 
+       (ball.sprite.x - BALL_WIDTH >= player1.sprite.x - REAL_PLAYER_WIDTH) && 
+       (ball.sprite.y <= player1.sprite.y) && 
+       (ball.sprite.y >= (player1.sprite.y - PLAYER_HEIGHT))) 
        //dx=1;
        
        {
@@ -278,8 +256,8 @@ void update(void) {
     {
     ball.sprite.x = 160;
     ball.sprite.y = 128;
-    player.sprite.x = 16;
-    player.sprite.y = 120;
+    player1.sprite.x = 16;
+    player1.sprite.y = 120;
     player2.sprite.x = 320;
     player2.sprite.y = 180;
     player2.score += 1;
@@ -290,11 +268,11 @@ void update(void) {
     {
     ball.sprite.x = 160;
     ball.sprite.y = 128;
-    player.sprite.x = 16;
-    player.sprite.y = 120;
+    player1.sprite.x = 16;
+    player1.sprite.y = 120;
     player2.sprite.x = 320;
     player2.sprite.y = 180;
-    player.score += 1;
+    player1.score += 1;
     }  
 
     //Ball boundary limits
@@ -302,8 +280,8 @@ void update(void) {
     if (ball.sprite.y <= BALL_TOP_BOUNDARY) dy=2;
     
     //Player1 boundary limits
-    if (player.sprite.y < SCREEN_TOP_BOUNDARY) player.sprite.y = SCREEN_TOP_BOUNDARY;
-    if (player.sprite.y > SCREEN_BOTTOM_BOUNDARY) player.sprite.y = SCREEN_BOTTOM_BOUNDARY;
+    if (player1.sprite.y < SCREEN_TOP_BOUNDARY) player1.sprite.y = SCREEN_TOP_BOUNDARY;
+    if (player1.sprite.y > SCREEN_BOTTOM_BOUNDARY) player1.sprite.y = SCREEN_BOTTOM_BOUNDARY;
   
     //Player2 boundary limits
     if (player2.sprite.y < SCREEN_TOP_BOUNDARY) player2.sprite.y = SCREEN_TOP_BOUNDARY;
@@ -313,7 +291,7 @@ void update(void) {
 
 void update_hud(void) {
     char text[10];
-    sprintf(text, "%02d", player.score);
+    sprintf(text, "%02d", player1.score);
     nprint_string(&vctx, text, strlen(text), 7, 1);
 
     sprintf(text, "%02d", player2.score);
@@ -321,39 +299,23 @@ void update_hud(void) {
 }
 
 void draw(void) {
-    uint8_t err = gfx_sprite_render(&vctx, 0, &player.sprite);
-    err = gfx_sprite_render(&vctx, 1, &ball.sprite);
-    err = gfx_sprite_render(&vctx, 2, &player2.sprite);
-    if(err != 0) {
-        printf("graphics error: %d", err);
-        exit(1);
-    }
+    uint8_t err;
+    err = gfx_sprite_render(&vctx, player1.sprite_index, &player1.sprite);
+    // if(err != 0) {
+    //     printf("graphics error: player: %d", err);
+    //     exit(1);
+    // }
+
+    err = gfx_sprite_render(&vctx, ball.sprite_index, &ball.sprite);
+    // if(err != 0) {
+    //     printf("graphics error: ball: %d", err);
+    //     exit(1);
+    // }
+
+    err = gfx_sprite_render(&vctx, player2.sprite_index, &player2.sprite);
+    // if(err != 0) {
+    //     printf("graphics error: player2: %d", err);
+    //     exit(1);
+    // }
 }
 
-void __assets__(void) {
-    __asm__(
-    // pong palette
-    "__pong_palette_start:\n"
-    "    .incbin \"assets/pong.ztp\"\n"
-    "__pong_palette_end:\n"
-    // pong tiles
-    "__pong_tileset_start:\n"
-    "    .incbin \"assets/pong.zts\"\n"
-    "__pong_tileset_end:\n"
-
-    // numbers palette
-    "__numbers_palette_start:\n"
-    "    .incbin \"assets/numbers.ztp\"\n"
-    "__numbers_palette_end:\n"
-
-    // numbers tiles
-    "__numbers_tileset_start:\n"
-    "    .incbin \"assets/numbers.zts\"\n"
-    "__numbers_tileset_end:\n"
-
-    // tilemap
-    "__pong_tilemap_start:\n"
-    "    .incbin \"assets/pong.ztm\"\n"
-    "__pong_tilemap_end:\n"
-    );
-}
\ No newline at end of file
diff --git a/src/pong.h b/src/pong.h
index 8e16c60..5a08e17 100644
--- a/src/pong.h
+++ b/src/pong.h
@@ -6,17 +6,26 @@
 
 #pragma once
 
-#define FREE_TILE           0x01
-#define BACKGROUND_TILE     0x11
-#define PLAYER_TILE         0x09
-#define BALL_TILE           0xA
-#define PLAYER2_TILE        0xB
+#define FREE_TILE           1
+#define BACKGROUND_TILE     0
+#define PLAYER1_TILE         9
+#define BALL_TILE           10
+#define PLAYER2_TILE        11
 #define WIDTH               20
 #define HEIGHT              15
-#define TILE_SIZE           (16  * 16)
 #define TILEMAP_LAYER       0
 #define HUD_LAYER           1
 
+#define PLAYER_SPEED                1
+#define BALL_WIDTH                  3
+#define PLAYER_HEIGHT               16
+#define PLAYER_WIDTH                16
+#define REAL_PLAYER_WIDTH           6
+#define SCREEN_TOP_BOUNDARY         24
+#define SCREEN_BOTTOM_BOUNDARY      232
+#define BALL_TOP_BOUNDARY           8
+#define BALL_BOTTOM_BOUNDARY        232
+
 typedef struct {
     gfx_sprite sprite;
     uint8_t sprite_index;
diff --git a/src/utils.c b/src/utils.c
deleted file mode 100644
index 5ba438d..0000000
--- a/src/utils.c
+++ /dev/null
@@ -1,75 +0,0 @@
-#include <string.h>
-#include "utils.h"
-
-void print_string(gfx_context* ctx, const char* str, uint8_t x, uint8_t y)
-{
-    gfx_tilemap_load(ctx, str, strlen(str), 1, x, y);
-}
-
-void nprint_string(gfx_context* ctx, const char* str, uint8_t len, uint8_t x, uint8_t y)
-{
-    gfx_tilemap_load(ctx, str, len, 1, x, y);
-}
-
-/**
- * Retrieve the value of the R register
- *
- * This is can be used for a quick dirty "random" value
-*/
-char rand8_quick(void) __naked
-{
-    __asm__(
-    "ld a, r\n"
-    "ret\n"
-    );
-}
-
-/**
- * Return an 8-bit pseudo-random number
- *
- * This is a combination of an LFSR w/ Counter
-*/
-char rand8(void) __naked
-{
-    // credit: https://spectrumcomputing.co.uk/forums/viewtopic.php?t=4571
-    // __asm
-    // ;This code snippet is 9 bytes and 43cc
-    // ;Inputs:
-    // ;   HL is the input seed and must be non-zero
-    // ;Outputs:
-    // ;   A is the 8-bit pseudo-random number
-    // ;   HL is the new seed value (will be non-zero)
-
-    // ;-------------------------------------------------------------------------------
-    // ;Technical details:
-    // ;   The concept behind this routine is to combine an LFSR (poor RNG) with a
-    // ; counter. The counter improves the RNG quality, while also extending the period
-    // ; length.
-    // ;   For this routine, I took advantage of the Z80's built-in counter, the `r`
-    // ; register. This means that we don't need to store the counter anywhere, and it
-    // ; is pretty fast to access!
-    // ;   Some caveats:
-    // ;     * r is a 7-bit counter
-    // ;     * r will increment some number of times between runs of the RNG. In most
-    // ;       cases, this will be constant, but if it increments an even number each
-    // ;       time, then the bottom bit is always the same, weakening the effect of
-    // ;       the counter. In the worst case, it increments a multiple of 128 times,
-    // ;       effectively making your RNG just as good/bad as the LFSR. Ideally, you
-    // ;       want `r` to increment an odd number of times between runs.
-    // ;     * In the best case, the bottom 7 bits have 50/50 chance of being 0 or 1.
-    // ;       The top bit is 1 with probability 1/2 + 1/(2^17-2) ~ .5000076295
-    // ;     * In the event that your main loop waits for user input between calls,
-    // ;       then congatulations, you might have a True RNG :)
-    // ;-------------------------------------------------------------------------------
-
-    __asm__(
-    "            ;opcode cc\n"
-    "add hl,hl   ; 29    11\n"
-    "sbc a,a     ; 9F     4\n"
-    "and #0x2D   ; E62D   7\n"
-    "xor l       ; AD     4\n"
-    "ld l,a      ; 6F     4\n"
-    "ld a,r      ; ED5F   9\n"
-    "add a,h     ; 84     4\n"
-    );
-}
\ No newline at end of file
diff --git a/src/utils.h b/src/utils.h
deleted file mode 100644
index 5fba375..0000000
--- a/src/utils.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/**
- * SPDX-FileCopyrightText: 2024 Zeal 8-bit Computer <contact@zeal8bit.com>
- *
- * SPDX-License-Identifier: CC0-1.0
- */
-#pragma once
-
-#include <stdint.h>
-#include <zvb_gfx.h>
-
-void print_string(gfx_context* ctx, const char* str, uint8_t x, uint8_t y);
-void nprint_string(gfx_context* ctx, const char* str, uint8_t len, uint8_t x, uint8_t y);
-char rand8_quick(void);
-char rand8(void);
\ No newline at end of file
